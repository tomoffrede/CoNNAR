---
title: "Preprocessing"
author: "Tom Offrede"
date: "2023-05-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Read TextGrids, which contain annotation of turn duration and phonetic transcription, and create dataset with speech rate in each audio file.

```{r}
library(stringr)
library(tidyverse)
library(rPraat)

folderData <- paste0(here::here(), "/data/corrected/")
folderTurn <- paste0(here::here(), "/data/final/")

files <- list.files(folderData, "TextGrid")
files <- files[grepl("free", files)]
filesT <- list.files(folderTurn, "\\.TextGrid")

ff <- data.frame(files = files,
                 turn = rep(filesT, each=2)) %>% 
  mutate(worked = ifelse(str_split(files, fixed("_"))[[1]][[1]] == str_split(turn, fixed("_"))[[1]][[1]] &
                           str_split(files, fixed("_"))[[1]][[2]] == str_split(turn, fixed("_"))[[1]][[2]] &
                           str_split(files, fixed("_"))[[1]][[3]] == str_split(turn, fixed("_"))[[1]][[3]],
                         "worked!", "NO!!!"))
table(ff$worked)
```
# use MAU intervals to obtain IPUs

IPUs are periods of voice activity with no pauses longer than 150ms

```{r}
for(f in files){
  tg <- tg.read(paste0(folderData, f), encoding = detectEncoding(paste0(folderData, f)))
  
  tg <- tg.duplicateTier(tg, "MAU", newInd = Inf, newTierName = "IPU")
  
  # join all consecutive intervals that are non-silent
  for(i in 1:(tg.getNumberOfIntervals(tg, "IPU")-1)){
    if(i > (tg.getNumberOfIntervals(tg, "IPU")-1)){
      next
    }
    if(tg.getLabel(tg, "IPU", i) != "<p:>"){
      if(tg.getLabel(tg, "IPU", i+1) != "<p:>"){
        tg <- tg.removeIntervalRightBoundary(tg, "IPU", i)
        i <- i - 1
      }
    }
  }
  
  # join into one IPU the intervals that are separated by pauses shorter than 150 ms
  for(i in 1:(tg.getNumberOfIntervals(tg, "IPU")-2)){
    if(i > (tg.getNumberOfIntervals(tg, "IPU")-2)){
      next
    }
    if(tg.getLabel(tg, "IPU", i) != "<p:>"){ # if the current interval is not silent
      if(tg.getLabel(tg,"IPU", i+1) == "<p:>"){ # if the next interval is silent
        if(tg.getIntervalDuration(tg, "IPU", i+1) < 0.15){ # if the next interval is shorter than 150 ms
          if(tg.getLabel(tg, "IPU", i+2) != "<p:>"){ # if the subsequent (after the next) interval is also not silent
            tg <- tg.removeIntervalBothBoundaries(tg, "IPU", i+1) # remove both boundaries of the short pause interval
          }
        }
      }
    }
  }

  # relabel the intervals
  for(i in 1:tg.getNumberOfIntervals(tg, "IPU")){
    if(tg.getLabel(tg, "IPU", i) != "<p:>"){
      tg <- tg.setLabel(tg, "IPU", i, "ipu")
    }
  }
  
  tg.write(tg, paste0(folderTurn, f))
}
```


```{r}
# to check file naming

# names <- data.frame(matrix(nrow=0, ncol=4))
# names(names) <- c("1", "2", "3", "4")
# for(f in files){
#   s <- str_split(gsub(".TextGrid", "", f), fixed("_"))[[1]]
#   names[nrow(names)+1,] <- c(s[[1]], s[[2]], s[[3]], s[[4]])
# }
# names
```


```{r}
# to check what phones there are and what words they come from

# phones <- data.frame(matrix(nrow=0, ncol=4))
# names(phones) <- c("file", "phone", "word", "wordPhon")
# for(f in 1:nrow(ff)){
#   tg <- tg.read(paste0(folderData, ff$files[f]), encoding = detectEncoding(paste0(folderData, ff$files[f])))
#   
#   for(i in 1:tg.getNumberOfIntervals(tg, "MAU")){
#     if(tg.getLabel(tg, "MAU", i) != ""){
#       phones[nrow(phones)+1,] <- c(f,
#                                    tg.getLabel(tg, "MAU", i),
#                                    tg.getLabel(tg, "ORT-MAU", tg.getIntervalIndexAtTime(tg, "ORT-MAU", as.numeric(tg.getIntervalStartTime(tg, "MAU", i))+0.000001)),
#                                    tg.getLabel(tg, "KAN-MAU", tg.getIntervalIndexAtTime(tg, "KAN-MAU", as.numeric(tg.getIntervalStartTime(tg, "MAU", i))+0.000001)))
#     }
#   }
# }
# phones <- phones %>% filter(phone!="<p:>")
# p <- aggregate(word ~ phone, phones, paste, collapse=",")
```


```{r}
int <- data.frame(matrix(nrow=0, ncol=13))
names(int) <- c("file", "dyad", "speaker", "confederate", "turn", "intervalTRN", "label", "intOnset", "intOffset", "intDur", "deleteDur", "invalidTurn", "vowels")

for(f in 1:nrow(ff)){
  tg <- tg.read(paste0(folderData, ff$files[f]), encoding = detectEncoding(paste0(folderData, ff$files[f])))
  tgTurn <- tg.read(paste0(folderTurn, ff$turn[f]), encoding = detectEncoding(paste0(folderTurn, ff$turn[f])))
  
  for(i in 1:tg.getNumberOfIntervals(tg, "TRN")){
    if(tg.getLabel(tg, "TRN", i) != ""){
      del <- 0
      vowels <- 0
      
      int[nrow(int)+1,] <- c(f,
                             str_split(ff$files[f], fixed("_"))[[1]][[1]],
                             ifelse(grepl("_ch1", f), "confederate", "participant"),
                             str_split(ff$files[f], fixed("_"))[[1]][[2]],
                             NA, # this will be turn
                             i,
                             tg.getLabel(tg, "TRN", i),
                             tg.getIntervalStartTime(tg, "TRN", i),
                             tg.getIntervalEndTime(tg, "TRN", i),
                             tg.getIntervalDuration(tg, "TRN", i),
                             NA, NA, NA
      )
      
      # now annotate turns
      
      tier <- paste0("turn-", str_split(ff$files[f], fixed("_"))[[1]][[4]])
      for(t in 1:nrow(tgTurn, tier)){
        if(tg.getIntervalStartTime(tgTurn, tier, t) <= tg.getIntervalStartTime(tg, "TRN", i)){
          if(tg.getIntervalEndTime(tgTurn, tier, t) >= tg.getIntervalEndTime(tg, "TRN", i)){
            int$turn[nrow(int)] <- tg.getLabel(tgTurn, tier, t)
          }
        }
      }
      
      # now write down the periods of time to delete due to them being annotated as <usb>, <nib>, or <pseudo>
      if(grepl("<", int$label[nrow(int)])){
        for(p in c(tg.getIntervalIndexAtTime(tg, "MAU", as.numeric(int$intOnset[nrow(int)])):
                   tg.getIntervalIndexAtTime(tg, "MAU", as.numeric(int$intOffset[nrow(int)])))){
          if(tg.getIntervalStartTime(tg, "MAU", p) >= int$intOnset[nrow(int)]){ # make sure the phone interval starts and ends within the TRN interval, since they aren't perfectly aligned
            if(tg.getIntervalEndTime(tg, "MAU", p) <= int$intOffset[nrow(int)]){
              if(grepl("<", tg.getLabel(tg, "MAU", p))){
                del <- as.numeric(del + as.numeric(tg.getIntervalDuration(tg, "MAU", p))) # if there are multiple "<>" intervals, we add up all of them
              }
            }
          }
        }
      }
      int$deleteDur[nrow(int)] <- as.numeric(del)
      if(int$label[nrow(int)] == "<nib>" | int$label[nrow(int)] == "<pseudo>" | int$label[nrow(int)] == "<usb>"){ # delete the turns that are entirely a forbidden string
        int$invalidTurn[nrow(int)] <- "yes"
      }
      if(is.na(int$invalidTurn[nrow(int)])){
        for(p in c(tg.getIntervalIndexAtTime(tg, "MAU", as.numeric(int$intOnset[nrow(int)])):
                   tg.getIntervalIndexAtTime(tg, "MAU", as.numeric(int$intOffset[nrow(int)])))){
          if(tg.getIntervalStartTime(tg, "MAU", p) >= int$intOnset[nrow(int)]){
            if(tg.getIntervalEndTime(tg, "MAU", p) <= int$intOffset[nrow(int)]){
              if(grepl("@|2|9|a|E|e|I|i|O|o|U|u|y|Y", tg.getLabel(tg, "MAU", p))){
                vowels <- vowels + 1
              }
              if(grepl("6", tg.getLabel(tg, "MAU", p))){ # if the vowel is "6", it should only be counted as a different syllable if the previous phone wasn't a vowel
                if(!grepl("@|2|9|a|E|e|I|i|O|o|U|u|y|Y", tg.getLabel(tg, "MAU", p-1))){
                  vowels <- vowels + 1
                }
              }
            }
          }
        }
      }
      int$vowels[nrow(int)] <- vowels
    }
  }
}

int <- int %>% 
  group_by(file) %>% 
  mutate(IPU = 1:n()) %>% 
  ungroup %>% 
  mutate_at(c("intDur", "deleteDur", "vowels"), as.numeric) %>% 
  mutate(realDur = ifelse(is.na(invalidTurn), intDur - deleteDur, NA),
         artRate = vowels / realDur)
```
